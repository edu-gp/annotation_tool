steps:
# Build the alchemy test image
#
- name: 'gcr.io/cloud-builders/docker'
  args: ['build',
         '--target', 'test',
         '--tag', 'gcr.io/$PROJECT_ID/alchemy:test-${SHORT_SHA}',
         '.']
  id: 'build-test-image'

# Run the tests, to prevent having broken
# images. May look unnecessary since there are
# GitHub actions that run tests, however it
# wouldn't hurt to double check.
#
- name: 'gcr.io/cloud-builders/docker'
  args: ['run',
         '--env', 'GOOGLE_AI_PLATFORM_ENABLED=0',
         '--env', 'USE_CLOUD_LOGGING=0',
         'gcr.io/$PROJECT_ID/alchemy:test-${SHORT_SHA}',
         'sh', 'ci/run_tests.sh']
  wait_for: ['build-test-image']
  id: 'run-tests'

# Build the target image (if target != test)
#
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: "bash"
  args:
    - "-c"
    - |
       if [ "${_TARGET}" != "test" ]; then
        docker build \
            --target ${_TARGET} \
            --cache-from gcr.io/$PROJECT_ID/alchemy:test-${SHORT_SHA} \
            --tag gcr.io/$PROJECT_ID/alchemy:${_TARGET}-${SHORT_SHA} \
            .
        else
          echo Skipped rebuilding the test image
        fi
  wait_for: ['run-tests']
  id: 'build-target-image'

# Tag the target as latest in case it is a production image
#
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: "bash"
  args:
    - "-c"
    - |
        if [ "${_TARGET}" = "production" ]; then
          echo Tagging production image as latest
          docker tag gcr.io/$PROJECT_ID/alchemy:${_TARGET}-${SHORT_SHA} gcr.io/$PROJECT_ID/alchemy:latest
          echo Pushing gcr.io/$PROJECT_ID/alchemy:latest
          docker push gcr.io/$PROJECT_ID/alchemy:latest
        else
          echo Not production target, not tagging as latest.
        fi
  id: 'tag-latest'
  wait_for: ['build-target-image']

timeout: 1200s
images:
  - 'gcr.io/$PROJECT_ID/alchemy:${_TARGET}-${SHORT_SHA}'
